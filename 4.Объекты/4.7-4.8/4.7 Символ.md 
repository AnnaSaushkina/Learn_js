
**Это уникальный ключ для свойств объекта**
не доступен для перебора простыми способами:
- object.keys
- циклом for in


Достучаться до них можно с помощью:
`Object.getOwnPropertySymbols()`

**Каждый вызов symbol возвращает уникальное значение**
```javascript
const id1 = Symbol('id');
const id2 = Symbol('id');

console.log(id1 === id2); // false ← Ключевой момент!
console.log(id1); // Symbol(id)
console.log(id2); // Symbol(id) ← Выглядят одинаково, но разные!
```

**Тип символ не преобразуется неявно**
- Можно преобразовать явно к строке или числу
```javascript
const sym = Symbol('test');
console.log(sym + 10); 
// TypeError: Cannot convert a Symbol value to a number
console.log(`${sym}`); 
// TypeError: Cannot convert a Symbol value to a string
```

 Symbol.for('id') === Symbol.for('id')
   - `Symbol.for()` использует глобальный реестр
   - Сначала ищет символ с таким ключом, если нет — создает
   - `Symbol()` всегда создает новый символ
```javascript
const id1 = Symbol.for('id'); // Ищет в глобальном реестре
const id2 = Symbol.for('id'); // Находит тот же символ

console.log(id1 === id2); // true 
console.log(Symbol.keyFor(id1)); // 'id' Можем получить ключ
```



 **ГЛАВНЫЕ ВЫВОДЫ:**

- Символ нужен чтобы не было конфликтов при перезаписи имен
- когда нужно скрыть служебные свойства от пользователя
- когда нужно добавить объекту информацию без изменения его структуры (метаданные)
- для кастомизации поведения объектов?— Symbol.iterator, Symbol.toPrimitive и другие
- когда нужны уникальные значения-константы


1. **Symbol.for() / Symbol.keyFor()** — для работы с глобальным реестром символов

Проблемы:
- к символ-свойствавм чуть медленнее доступ
- символ не попадает в json для сериализации
- если пользователи api должны видеть и использовать свойство
