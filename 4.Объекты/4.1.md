## **1. Объекты - это ссылочные типы**

```javascript
const obj1 = { a: 1 };
const obj2 = obj1; // Копируется ссылка, не объект!
obj2.a = 2;
console.log(obj1.a); // 2 - изменился исходный объект!
```

При присваивании объекта создается новая ссылка на тот же объект в памяти.

## **2. Контекст выполнения (Execution Context)**

Каждая функция создает свой контекст выполнения, который включает:
- Переменные окружения (Lexical Environment)
- Ссылку на `this`
- Ссылку на внешнее лексическое окружение

```javascript
function test() {
  console.log(this); // зависит от вызова!
}
```


### **Вызов метода (implicit binding)**
```javascript
const obj = {
  name: "John",
  sayName() {
    console.log(this.name); // this = obj
  }
};
obj.sayName(); // "John" - this определяется объектом перед точкой
```

### **Простой вызов функции (default binding)**
```javascript
function showThis() {
  console.log(this); // в strict mode = undefined, иначе = global/window
}

const obj = {
  method() {
    function inner() {
      console.log(this); // undefined (strict mode) - потеря контекста!
    }
    inner();
  }
};
```

### **Явная привязка (explicit binding)**
```javascript
function greet() {
  console.log(`Hello, ${this.name}`);
}

const user = { name: "Alice" };

greet.call(user);    // Hello, Alice
greet.apply(user);   // Hello, Alice
const bound = greet.bind(user);
bound();             // Hello, Alice
```

### **Конструктор (new binding)**
```javascript
function User(name) {
  this.name = name; // this = новый пустой объект
  // return this (неявно)
}

const user = new User("Bob");
```

## **Стрелочные функции - исключение**

```javascript
const obj = {
  name: "Test",
  regular() {
    console.log(this.name); // "Test" - определяется в момент вызова
  },
  arrow: () => {
    console.log(this.name); // undefined - определяется в момент создания
  }
};

// Стрелочная функция берет this из внешнего лексического окружения
```

## **Приоритет правил**

**new → explicit → implicit → default**

```javascript
function test() {
  console.log(this.name);
}

const obj1 = { name: "Implicit" };
const obj2 = { name: "Explicit" };

const bound = test.bind(obj2);
bound.call(obj1); // "Explicit" - bind имеет приоритет
```

## **Скрытые механизмы**

### **Неявная передача this**
```javascript
// Когда вызываем obj.method(), происходит:
// временная переменная = obj
// временная переменная.method()
```

### **Методы vs Свойства-функции**
```javascript
const obj = {
  method() { console.log(this); },        // метод объекта
  func: function() { console.log(this); } // свойство-функция (поведение одинаково)
};

const extracted = obj.method;
extracted(); // потеря контекста!
```

## **7. Особые случаи**

### **Callback-функции**
```javascript
const obj = {
  name: "John",
  delayedGreet() {
    setTimeout(function() {
      console.log(this.name); // undefined - this переопределен!
    }, 100);
    
    // Решения:
    setTimeout(() => console.log(this.name), 100); // стрелочная
    setTimeout(function() { console.log(this.name); }.bind(this), 100); // bind
  }
};
```

### **Getter/Setter**
```javascript
const obj = {
  _name: "",
  get name() {
    return this._name; // this работает как в методах
  },
  set name(value) {
    this._name = value;
  }
};
```


## **Ключевые выводы:**

1. **`this` не привязывается к объекту, а определяется способом вызова**
2. **Стрелочные функции - исключение (лексический `this`)**
3. **Контекст теряется при передаче методов как callback'ов**
4. **`bind/call/apply` позволяют управлять контекстом явно**
5. **При создании через `new` `this` связывается с новым объектом**

