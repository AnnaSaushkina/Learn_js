**Переменная может содержать изменяемые (по типу) данные:**<br>

Примитивные типы
```js
let name = "Anna"
let age = 26
let isCoder = true
let moodStatus = undefined
let cashValue = null // typeof null === 'object'

//ES6
let cryptoAccountValue = 3.14159265358979323846
let idAccount = Symbol("id")
```

* Содержат только одно значение
* Полностью перезаписываются, а не изменяются
```js
const a = 5
const b = 5
console.log(a == b) // true
console.log( a === b) // true
// a и b одно и то же значение в памяти
```


**Объект как не примитивный тип**
* **Не примитивные типы умеют ссылаться на разные значения в памяти**
* Хранит коллекцию значений любого типа и др сложных сущностей (массивы, функции)
* Хранится в переменной по ссылке (как и массивы с функциями)
```js
const a = [1, 2, 3]
const b = [1, 2, 3]
console.log(a == b)
// false
// массивы внутри a и b это разные массивы
```
Литерал объекта / литеральная нотация
```js
let usersInfo = {
    name: userName,
    age: 20,
    city: "Moscow"
}
```

Создание конструктора объекта 
```js
let userCard = new Object();
userCard.name = "Anna"
console.log(userCard.name) // Anna
```
```js
let user = {
  name: "John",
  age: 30,
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};
```

## Преобразование типов и их проверка
**Явное преобразование** с помощью функции 
```js
const x = '4'
Number(4)// строка становится числом
```
**Не строгое сравнение**
```js
console.log(5 == '5') //true
```
**Строгое сравнение**
```js
console.log(5 === '5') //false
```
* Можно конвертировать в строку **String()**,<br>
* в число **Number()** - если не приводится, то получаем **NaN**<br>
* в булево значение **Boolean()**:<br>
```js
Boolean(NaN);
Boolean(null);
Boolean(undefined);
Boolean(0);
Boolean(""); 
//false
```




## Задачи
#### Задача 1
Напишите код, выполнив задание из каждого пункта отдельной строкой:

1. Создайте пустой объект user.
2. Добавьте свойство name со значением John.
3. Добавьте свойство surname со значением Smith.
4.Измените значение свойства name на Pete.
5. Удалите свойство name из объекта.
```js
let user = new Object()
user.name = "John"
user.surname = "Smith"
user.name = "Pete"
delete user.name
//{surname: "Smith"}
```

___


#### Задача 2

Напишите код, выполнив задание из каждого пункта отдельной строкой:

Можно ли изменить объект, объявленный с помощью const? Как вы думаете?


```js
const user = {
  name: "John"
};

// это будет работать?
user.name = "Pete"; 
// значение будет меняться, так как объект хранится по ссылке.
```
___
#### Задача 3 Сумма свойств объекта
У нас есть объект, в котором хранятся зарплаты нашей команды:

```js
let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}
let sum = salaries.John + salaries.Ann + salaries.Pete
console.log(sum)//390
```
Напишите код для суммирования всех зарплат и сохраните результат в переменной sum. Должно получиться 390.

Если объект salaries пуст, то результат должен быть 0.
___
#### Задача 4 Умножаем все числовые свойства на 2
Создайте функцию multiplyNumeric(obj), которая умножает все числовые свойства объекта obj на 2.

```js
// до вызова функции
let menu = {
  width: 200,
  height: 300,
  title: "My menu"
};

multiplyNumeric(menu);

// после вызова функции

function multiplyNumeric(menu) {
  let menuWidth = menu.width * 2;
  menu.width = menuWidth;

  let menuHeight = menu.height * 2;
  menu.height = menuHeight;
}
 console.log(menu)

// Результат:  menu = {
//   width: 400,
//   height: 600,
//   title: "My menu"
// };
```

___
04.11

 * Почему тип функция воспринимает как функция?
 ```js
 let newFunc = function() {}
 console.log(typeof(newFunc)) // function
 ```
 typeof  определить тип выражением, представляющим объект или примитив
проверки на принадлежность значения категории функций, где функция - это особый, "вызываемый", объект.
Функции — это обычные объекты, имеющие дополнительную возможность быть вызванными для исполнения.
В JavaScript функция — это тип данных, примерно такой же как объект или строка. Это означает, что с ним можно работать так же, как и с любым другим типом данных — сохранять в переменную, передавать в качестве аргумента функции, возвращать из функций
функции являются объектами первого класса
 функции первого класса, если он рассматривает функции как объекты первого класса. В частности, это означает, что язык поддерживает передачу функций в качестве аргументов другим функциям, возврат их как результат других функций, присваивание их переменным или сохранение в структурах данных


 * сформулировать ответ разницы null и undefined