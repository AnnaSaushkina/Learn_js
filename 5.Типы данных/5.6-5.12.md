## 1. Map и Set

### Задача 1 — Подсчёт посещений страницы (Map)

**Цель:** потрогать `Map`, ключи‑строки и работу через `set/get`.

Напиши функцию `countVisits(pages)`, которая:

- принимает массив строк с названиями страниц, например:
  ```js
  const pages = ['home', 'about', 'home', 'cart', 'home', 'about'];
  ```
- возвращает `Map`, где:
  - ключ — название страницы,
  - значение — сколько раз она встретилась.

Пример ожидаемого:

```js
countVisits(['home', 'about', 'home']);
// Map { "home" => 2, "about" => 1 }
```

---

## Ключевые тезисы про `Map`

1. `Map` — это “объект, где можно чем угодно быть ключом”
   - Ключами могут быть строки, числа, объекты, функции — что угодно.

2. Создание и базовые методы

```js
const map = new Map();

map.set(key, value); // записать
map.get(key); // прочитать (или undefined, если нет)
map.has(key); // проверить наличие ключа (true/false)
map.size; // количество пар ключ-значение
```

3. Типичный “count map” (подсчёт встречаемости)

Шаблон, который прям нужен для твоего `countVisits`:

```js
const counts = new Map();

for (const item of array) {
  const current = counts.get(item) || 0; // если нет — считаем 0
  counts.set(item, current + 1);
}
```

То есть:

- `get(item)` → либо число (сколько раз уже встречали), либо `undefined`;
- `|| 0` превращает `undefined` в 0;
- `set(item, current + 1)` увеличивает счётчик.

4. Перебор `Map`

Если потом захочешь вывести результат:

```js
for (const [page, count] of counts) {
  console.log(page, count);
}
```

---

## Как это применить к твоей задаче

Твоя заготовка:

```js
// Задача 1 — Подсчёт посещений страницы (Map)
function countVisits(pages) {
  return Map;
}

const pages = ['home', 'about', 'home', 'cart', 'home', 'about'];
console.log(countVisits(pages));
```

Направление мысли:

- создать внутри `countVisits` новый `Map`;
- пройтись циклом по `pages` (через `for...of`);
- для каждой `page` обновить счётчик по шаблону “current + 1”;
- вернуть именно `map`, а не `Map` (с маленькой буквы и как переменную, а не конструктор).

Чтобы проверить, зацепилось ли: как бы ты сама сейчас словом описала, в чём ключевое отличие `Map` от обычного объекта `{}` именно для задачи “подсчитать сколько раз встретилась каждая строка в массиве”?

---

### Задача 2 — Уникальные значения (Set)

**Цель:** почувствовать, что `Set` сам убирает дубликаты.

Напиши функцию `getUniqueUsers(logins)`, которая:

- принимает массив логинов, где один пользователь может встречаться много раз:
  ```js
  const logins = ['ann', 'bob', 'ann', 'kate', 'bob'];
  ```
- возвращает **массив уникальных логинов** с помощью `Set`.

---

### Задача 3 — Кеширование вычислений (Map + объект в качестве ключа)

**Цель:** использовать объект как ключ в `Map`.

Есть функция `calculateUserScore(user)`, которая просто возвращает, скажем, длину имени:

```js
function calculateUserScore(user) {
  return user.name.length;
}
```

Напиши обёртку `makeScoreCache()`, которая:

- создаёт внутри `Map`,
- возвращает функцию `getScore(user)`, которая:
  - если для этого объекта `user` уже считали score — берёт из `Map`,
  - если нет — считает через `calculateUserScore`, кладёт в `Map` и возвращает.

То есть хочешь реализовать **ручной кеш** на `Map`.

---

## 2. WeakMap и WeakSet

### Задача 4 — Хранение “метаданных” для объектов (WeakMap)

**Цель:** понять “почему именно Weak”.

Создай `WeakMap`, в которой:

- ключ — объект пользователя `user`,
- значение — дата последнего логина, например `new Date()`.

Напиши две функции:

- `setLastLogin(user)` — кладёт/обновляет запись в `WeakMap`;
- `getLastLogin(user)` — возвращает дату или `null`, если записи нет.

Важно: здесь тебя не попросят “увидеть” сборщик мусора, просто потрогать API `WeakMap` и привязку данных к объекту.

---

### Задача 5 — Множество только объектов (WeakSet)

**Цель:** понять, чем `WeakSet` отличается от `Set`.

Сделай `WeakSet` `visitedUsers` и функцию:

- `markVisited(user)` — помечает пользователя как “зашёл на страницу”;
- `isVisited(user)` — возвращает `true/false`, был ли пользователь помечен.

Здесь важно, что `WeakSet` может содержать только объекты и не даёт методов типа `size`, но позволяет проверять через `has`.

---

## 3. Object.keys / values / entries

### Задача 6 — Преобразовать объект в массив пар

**Цель:** потренироваться в `Object.entries`.

Есть объект:

```js
const user = {
  name: 'Ann',
  age: 25,
  city: 'Moscow',
};
```

Напиши функцию `toPairs(obj)`, которая:

- возвращает массив вида:
  ```js
  [
    ['name', 'Ann'],
    ['age', 25],
    ['city', 'Moscow'],
  ];
  ```
- использует `Object.entries`.

---

### Задача 7 — Сумма значений объекта

**Цель:** потренироваться в `Object.values`.

Есть объект:

```js
const salaries = {
  ann: 1000,
  bob: 1500,
  kate: 1300,
};
```

Напиши функцию `sumSalaries(obj)`, которая возвращает сумму всех зарплат.

---

## 4. Деструктурирующее присваивание

### Задача 8 — Деструктурировать настройки

**Цель:** потрогать деструктуризацию объекта с дефолтами.

Есть функция `initSlider(options)`, которая ожидает объект:

```js
// options:
// {
//   speed: number (по умолчанию 300),
//   autoPlay: boolean (по умолчанию false),
//   delay: number (по умолчанию 5000)
// }
```

Сделай внутри деструктуризацию:

```js
const { speed = 300, autoPlay = false, delay = 5000 } = options;
```

и выведи эти значения. А вызовы, например:

```js
initSlider({ speed: 1000 });
initSlider({ autoPlay: true, delay: 2000 });
```

---

### Задача 9 — Поменять элементы местами через деструктуризацию

**Цель:** применить деструктуризацию массива.

Напиши функцию `swapFirstTwo(arr)`, которая:

- принимает массив из минимум двух элементов,
- меняет местами первые два элемента **через деструктуризацию**, а не через временную переменную.

---

## 5. Date

### Задача 10 — Вычислить возраст по дате рождения

**Цель:** потрогать `Date`, `getFullYear`.

Напиши функцию `getAge(birthDateString)`, которая:

- принимает строку вида `"1995-06-10"`,
- создаёт `Date` из неё,
- по текущей дате считает возраст (в годах, округляя вниз).

---

### Задача 11 — Сколько дней осталось до даты

**Цель:** поработать с разницей дат.

Напиши функцию `daysUntil(dateString)`, которая:

- принимает дату в будущем `"2026-12-31"`,
- возвращает целое число дней до неё от “сегодня”.

---

## 6. JSON и toJSON

### Задача 12 — Сериализация и восстановление

**Цель:** потрогать `JSON.stringify` и `JSON.parse`.

Напиши функции:

- `saveUser(user)` — принимает объект `user` и возвращает строку JSON;
- `loadUser(json)` — принимает строку JSON и возвращает объект.

Потренируйся с вложенными объектами, не только плоскими.

---

### Задача 13 — Кастомный `toJSON`

**Цель:** понять, как `toJSON` влияет на `JSON.stringify`.

Создай объект:

```js
const user = {
  name: 'Ann',
  password: 'secret',
  toJSON() {
    // тут нужно вернуть объект без пароля
  },
};
```

Сделай так, чтобы `JSON.stringify(user)` **не включал пароль**, а только безопасные поля (например, `name`).

---
