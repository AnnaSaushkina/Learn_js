# Map / Set / WeakMap / WeakSet

## 1. Map и Set (основа)

### Map

- Коллекция пар `key → value`.
- Ключ и значение — **любой тип** (строки, числа, объекты, функции и т.д.).
- Сохраняет **порядок вставки**.
- Основные методы:
  - `map.set(key, value)`
  - `map.get(key)`
  - `map.has(key)`
  - `map.delete(key)`
  - `map.clear()`
  - `map.size`
  - итерация: `for..of`, `map.keys()`, `map.values()`, `map.entries()`, `map.forEach()`.

Когда использовать:

- Нужен “настоящий словарь” с **динамическими ключами**, не только строками.
- Много операций добавления/удаления/поиска, важен порядок и удобное API.

---

### Set

- Коллекция **уникальных значений** любого типа.
- Основные методы:
  - `set.add(value)`
  - `set.has(value)`
  - `set.delete(value)`
  - `set.clear()`
  - `set.size`
  - итерация: `for..of`, `set.keys()`, `set.values()`, `set.entries()`.

Когда использовать:

- Убрать дубликаты из массива.
- Хранить “множество”: набор id, посещённые элементы и т.п.
- Быстро проверять “есть ли элемент”.

---

## 2. WeakMap и WeakSet (про память)

Общее:

- Хранят **только объекты** (в ключах WeakMap — объекты; значения любые).
- Держат объекты **слабыми ссылками** — не мешают сборщику мусора.
- Если на объект больше нет других ссылок, он может быть собран, и запись
  автоматически исчезнет из коллекции.
- **Не итерируемые**, нет `size` — нельзя надёжно перечислить содержимое,
  потому что элементы могут исчезнуть в любой момент.

Причина неитерируемости: “живость” ключей/элементов контролирует GC,
его работа недетерминирована, движок не обязан сообщать, что именно ещё живо.

---

### WeakSet

- Аналог `Set`, но:
  - Хранит только **объекты**.
  - Слабые ссылки, не мешает GC.
- Типичные use‑case’ы:
  - Помечать объекты как “посещённые/обработанные” (обход графа/DOM),
    не добавляя поля прямо на объект.
  - Следить за объектами, которые могут исчезать (DOM‑узлы), не создавая
    утечки памяти.

---

### WeakMap

- Аналог `Map`, но:
  - Ключи — только **объекты** (в практике обычно так и говорят).
  - Значения — любой тип.
  - Ключи держатся слабо: объект‑ключ собран → запись исчезла.
- Типичные use‑case’ы:
  - Привязка “секретных” / служебных данных к объекту (DOM‑узлу, юзеру,
    инстансу класса) без риска утечек: удалили объект — очистилась и запись.
  - Кэширование вычислений по объекту (object → result) без бесконечного
    роста памяти.

---

## 3. Object vs Map

- **Object**
  - Фиксированная, относительно небольшая структура.
  - Конфиги, DTO, данные, которые удобно сериализовать в JSON.
  - Ключи — в основном строки/символы.

- **Map**
  - “Живой словарь”: динамические ключи (включая объекты), много операций.
  - Нужен порядок вставки, `size`, нормальная итерация и гарантированное поведение.

---

- **Set** — уникальные значения, дедупликация, membership‑check.
- **Map** — словарь `ключ → значение` с любым типом ключей.
- **WeakSet** — “visited” для объектов без утечек и без доп. полей.
- **WeakMap** — приватные/служебные данные и кэш, привязанные к объекту,
  которые исчезают вместе с объектом.

- Если нужны:
  - перечислить содержимое, знать размер → **Map/Set**.
  - привязать данные к объекту и не держать его в памяти → **WeakMap/WeakSet**.
